<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/html" xmlns="http://www.w3.org/1999/html">
<head>
    <title>RGB-Pi communication protocol</title>
    <link rel="stylesheet" href="styles/default.css">
    <link rel="stylesheet" href="protocol.css">
    <script src="highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
</head>
<body>
    <div id="root"></div>

    <h1>RGB-Pi communication protocol</h1>

    <div id="index">
        <h2>Index</h2>
        <ol>
            <li>
                <a href="#communication">Communication</a>
                <ol>
                    <li><a href="#communication-syntax">Request/Answer syntax</a></li>
                    <li><a href="#communication-basic">Basic Communication</a></li>
                    <li><a href="#communication-answer">Answer</a></li>
                    <li><a href="#communication-examples">Examples</a></li>
                </ol>
            </li>

            <li>
                <a href="#commands">Commands</a>
                <ol>
                    <li><a href="#command-cc">cc - Change Color</a></li>
                    <li><a href="#command-fade">fade - Fade to color</a></li>
                    <li><a href="#command-wait">wait - Wait an amount of time</a></li>
                    <li><a href="#command-list">list - Execute a list of Commands</a></li>
                    <li><a href="#command-loop">loop - Loop through a list of Commands</a></li>
                    <li><a href="#command-nop">nop - Do nothing</a></li>
                </ol>
            </li>
            <li>
                <a href="#filters">Filters</a>
                <ol>
                    <li><a href="#"></a></li>
                    <li><a href="#"></a></li>
                    <li><a href="#"></a></li>
                </ol>
            </li>
            <li>
                <a href="#requests">Requests</a>
                <ol>
                    <li><a href="#"></a></li>
                    <li><a href="#"></a></li>
                    <li><a href="#"></a></li>
                </ol>
            </li>
            <li>
                <a href="#datatypes">Data Types</a>
                <ol>
                    <li><a href="#datatype-color">Color</a></li>
                    <li><a href="#datatype-time">Time</a></li>
                    <li><a href="#datatype-condition">Condition</a></li>
                </ol>
            </li>
        </ol>
    </div>

    <p>The server can receive commands from third party applications, like mobile apps.</p>

    <p>
    To send a commands to the server, a TCP stream socket has to be initialized and connected to the raspberry pi host ip.
    The command has to be a string with a maximum size of 1024 bytes.
    By default the server listens to port <strong>4321</strong>, but this can be configured with <strong>configutre.py config</strong> or manually set in <strong>config.py</strong>.
    </p>

    <div id="communication">
        <h2>Communication</h2>
        <p>
            The whole communication in RGB-Pi is based on the exchange of JSON-objects.
            This means every message sent to the RGB-Pi server has to be a valid JSON-object serialized as string.
            After each sent message a JSON-object is sent back as answer and acknowledgement at the same time.
        </p>

        <h3 id="communication-syntax">Request/Answer syntax</h3>
        <p id="communication-client-message"><strong>Client request (client -> server)</strong></p>
        <pre><code>
            {
                "commands":[],  ##optional

                "filters":[],   ##optional

                "request":{}    ##optional
            }
        </code></pre>
        <p id="communication-server-answer"><strong>Answer/Acknowledge message (server -> client)</strong></p>
        <pre><code>
            {
                "commands":1|0,                 ##only available if 'commands'-node was present in client request

                "filters":1|0,                  ##only available if 'filters'-node was present in client request

                "request":{answer-to-request},  ##only available if 'request'-node was present in client request

                "error":[]                      ##always available, but empty array if no errors occurred
            }
        </code></pre>

        <p>In the code snippets above you can see the basic components of a communication session.
            To get more in detail we will show you first the complete sequence of actions happen during a
            communication between client and server and then show some examples for each message-/answer-part.
        </p>

        <h3 id="communication-basic">Basic communication flow</h3>
        <p>The low level actions that take place during communication are:</p>
        <ol>
            <li>CONNECT via TCP Socket to the IP:Port of the RGB-Pi server.</li>
            <li>SEND a serialized JSON-object as string in the format described <a href="#communication-client-message">above</a>.</li>
            <li>RECEIVE the answer for the sent request.</li>
            <li>CLOSE the TCP socket.</li>
        </ol>

        <h3 id="communication-answer">Answer</h3>
        <p>
            <p>
            The server processes the incoming client request and sends an answer in JSON-format as response.
            You can see in the <a href="#communication-server-answer">answer-syntax</a> that there are 4 possible nodes in the answer object from the server.
            </p>

            <p>
            The first two are simple to understand: if the client request contained at least one command/filter the answer object will have a corresponding node,
            whose value is <strong>1</strong> if the commands/filters were recognized and correctly initialized, otherwise the commands/filters node has a <strong>0</strong> as value.
            </p>

            <p>
            If the client contained a request node, the answer object will also contain a request node with the answer-content of the requested value/functionality.
            In some cases this isn't only a simple value, but can also be a complex json-object representing the answer to the request (like in the case of some XBMC-requests).
            </p>

            <p>
            The last node in the answer object, 'error', is always present.
            It contains a string array which is emtpy in the best case, otherwise it contains the errors/exceptions happened
            during the interpretation or initialization of the received client request.
            </p>

        </p>

        <h3 id="communication-examples">Examples</h3>
        <p>TODO</p>
    </div>





    <div id="commands">
        <h2>Commands</h2>
        <p><strong>Commands</strong> are the core elements of RGB-Pi.</p>
        <p>They need to be on first level of the communication json-object, referenced by the key: <strong>'commands'</strong>.
            There must be only one 'commands'-node with an array which contains a 0-n list of commands</p>
        <p>Some commands can also contain an array with sub-commands, in order to make it possible to build every imaginable effect you want.
        More details follow below.</p>

        <h3 id="command-syntax">Syntax</h3>
        <p>All commands need to have a "type" field with a value which corresponds the type of command.
            The order of the key:value pairs in a command is not important.</p>

        <!-- CC -->
        <h3 id="command-cc">cc - Change Color</h3>
        <h4>Description</h4>
        <p>The <strong>cc</strong> command changes the color directly. It is also possible calculate the new color with a given arithmetic operator.</p>
        <h4>Syntax</h4>
        <p>The JSON-object of the <strong>cc</strong> command must set "cc" as "type" and requires a <a href="#datatype-color">color object</a>.</p>
<pre><code>
{
    "commands":
    [
        {
            "type":"cc",
            "color":"COLOR"

            ##optional
            ,"operator"="*" ## possible operators are + , -, *, and /
        }
    ]
}
</code></pre>
        <h4>Examples - comparison to old protocol</h4>
        <p>
            In the old protocol, a call of cc would look like;
            <pre><code>cc COLOR</code></pre>
            Example: set LED color to red: <pre><code>cc {f:1,0,0}</code></pre>
        </p>
        <p>
            The new protocol accepts only JSON-objects. the same call would look like;
<pre><code>
{
    "commands":
    [
        {
            "type":"cc",
            "color":"{f:1,0,0}"
        }
    ]
}
</code></pre>

            Another example shows the color-arithmetic mechanic:
<pre><code>
{
    "commands":
    [
            {
                "type":"cc",
                "operator":"*",
                "color":"{f:0.1,0.1,0.1}"
            }
    ]
}
</code></pre>
            This would make the current color 10% darker.
        </p>


        <!-- FADE -->
        <h3 id="command-fade">fade - Fade to Color</h3>
        <h4>Description</h4>
        <p>The <strong>fade</strong> command changes the color over a given time. It's optionally possible to declare a start-color from which the fade starts transitioning to the end-color.</p>
        <h4>Syntax</h4>
        <p>
        The JSON-object of the <strong>fade</strong> command must set "fade" as "type". It requires a <a href="#datatype-time">time object</a> which defines
        the fading time and a <a href="#datatype-color">color object</a> as <strong>end</strong>-color. Additionally it's also possible to define a
        <strong>start</strong> color object from which the fading animation should start, if it's not present the current color is taken as <strong>start</strong>-color.
        <a href="#datatype-color">color object</a>.
        </p>
<pre><code>
{
    "commands":
    [
        {
            "type":"fade",
            "time":"TIME",

            ##optional
            "start":"COLOR",

            "end":"COLOR"
        }
    ]
}
</code></pre>
       <h4>Examples - comparison to old protocol</h4>
        <p>
            In the old protocol, a call of fade would look like;
            <pre><code>fade TIME COLOR [COLOR]</code></pre>
            Example: fade current color to red in 5 seconds: <pre><code>fade 5 {f:1,0,0}</code></pre>
        </p>
        <p>
            The new protocol accepts only JSON-objects. The same call would look like;
<pre><code>
{
    "commands":
    [
        {
            "type":"fade",
            "time":"{c:5}",
            "end":"{f:1,0,0}"
        }
    ]
}
</code></pre>

            Another example shows that it is also possible to start from a specific color:
<pre><code>
{
    "commands":
    [
       {
            "type":"fade",
            "time":"600",
            "start":"{b:0,0,255}",
            "end":"{f:0,0,0}"
       }
    ]
}
</code></pre>
            This would lead to a fade from blue to black (off) over 10 minutes.<br/>
            NOTE: The time value can also be a simple float value, it will be converted to a time object implicitly.
        </p>

        <!-- WAIT -->
        <h3 id="command-wait">wait - Wait an amount of time</h3>
        <h4>Description</h4>
        <p>
            The <strong>wait</strong> command does no color changes. It can be used like a 'sleep' command in various programming languages
            to let the current execution wait a defined time and continue after that time exceeds with the next command.
            It is usually used in <a href="#command-list">list</a>- or <a href="#command-loop">loop</a>-commands.
        </p>

        <h4>Syntax</h4>
        <p>
        The JSON-object of the <strong>wait</strong> command must set "wait" as "type". It only requires a <a href="#datatype-time">time object</a> which describes the amount of time should be waited.
        </p>
<pre><code>
{
    "commands":
    [
        {
            "type":"wait",
            "time":"TIME"
        }
    ]
}
</code></pre>

        <h4>Examples</h4>
        <p>
            In the following example RGB-Pi will wait 5 seconds and then change the current color to Green:

<pre><code>
{
    "commands":
    [
        {
            "type":"wait",
            "time":"{c:5}"
        },
        {
            "type":"cc",
            "color":"{x:00FF00}"
        }
    ]
}
</code></pre>




        <!-- LIST -->
        <h3 id="command-list">list - List of commands</h3>
        <h4>Description</h4>
        <p>The <strong>list</strong> object defines a list of commands which are executed one after another in the order they are defined in the "commands"-array. It also allows the nesting of commands.</p>
        <p>NOTE: The "commands"-array in the <a href="#communication-client-message">client request</a> is implicitly converted into a list command with the defined commands as children.</p>

        <h4>Syntax</h4>
        <p>
        The JSON-object of the <strong>list</strong> command must set "list" as "type".
        It must declare a "commands" attribute with an array-value that contains 0-n objects which again can be <a href="#commands">commands</a> of any type.
        </p>
<pre><code>
{
    "commands":
    [
        {
            "type":"list"
            "commands":[COMMAND1, COMMAND2, ...]
        }
    ]
}
</code></pre>

        <h4>Examples</h4>
        <p>
            In the following example RGB-Pi will fade over 1 minute to white, then wait 5 seconds and then switch the color to green immediately:

<pre><code>
{
    "commands":
    [
        {
            "type":"list"
            "commands":
            [
                {
                    "type":"fade",
                    "time":60,
                    "end":"{f:1,1,1}"
                },
                {
                    "type":"wait",
                    "time":"{c:5}"
                },
                {
                    "type":"cc",
                    "color":"{x:00FF00}"
                }
            ]
        }
    ]
}
</code></pre>


        <!-- LOOP -->
        <h3 id="command-loop">loop - looping through a list of commands while a condition is true</h3>
        <h4>Description</h4>
        <p>
            The <strong>loop</strong> object defines a list of commands which are executed one after another in the order they
            are defined in the "commands"-array. It also allows the nesting of commands.
            This command is similar to a traditional 'while-loop' in programming languages. Before the first and after the last command a
            <strong>condition</strong> is checked. If it is <strong>true</strong> the loop will continue executing the inner list of commands
            til the condition becomes <strong>false</strong>.
        </p>

        <h4>Syntax</h4>
        <p>
        The JSON-object of the <strong>loop</strong> command must set "loop" as "type".
        It must declare a "commands" attribute with an array-value that contains 0-n objects which again can be <a href="#commands">commands</a> of any type.
        It also must contain a "condition"-attribute which value is a <a href="#datatype-condition">condition</a>-object that defines the end of the loop.
        </p>
<pre><code>
 {
    "commands":
    [
        {
            "type":"loop",
            "condition":"CONDITION"
            "commands":[COMMAND1, COMMAND2, ...]
        }
    ]
}
</code></pre>

        <h4>Examples - comparison to old protocol</h4>
        <p>
            In the old protocol was a program called <strong>random fader</strong>, a call of it looked like;
            <pre><code>rf minTime maxTime minBrightness maxBrightness</code></pre>
            Example: fade to a random color over a random time between 1 and 20 seconds: <pre><code>rf 1 18 0.0 1.0</code></pre>
        </p>
        <p>
            The new protocol accepts only JSON-objects.
            To create a animation with the same behaviour you can combine the previously showed commands with the loop command:
<pre><code>
{
    "commands":
    [
        {
            "type":"loop",
            "condition":"{b:1}",
            "commands":
            [
                {
                    "type":"fade",
                    "time":"{r:1,20}",
                    "end":"{r:0-1,0-1,0-1}"
                }
            ]
        }
    ]
}
</code></pre>

            Another example shows the new equivalent of the <strong>jump</strong> command which switches the colors every few seconds:
            <pre><code>jump waitTime minBrightness maxBrightness</code></pre>
            Example: Jump every 5 seconds to a random color:
            <pre><code>jump 5 0 1</code></pre><br/>

            The same functionality in the new protocol:
<pre><code>
{
    "commands":
    [
       {
            "type":"loop",
            "condition":"{b:1}",
            "commands":
            [
                {
                    "type":"cc",
                    "color":"{r:0-1,0-1,0-1}"
                },
                {
                    "type":"wait",
                    "time":"5"
                }
            ]
       }
    ]
}
</code></pre><br/>

        Another example shows a more complex animation. It will fade over 20 seconds to red, then pulse between red and green 2 times,
        then pulse blue-black 10 times and then start over:
<pre><code>
{
    "commands":
    [
        {
            "type":"loop",
            "condition":"{b:1}",
            "commands":
            [
                {
                    "type":"fade",
                    "time":"20",
                    "end":"{f:1,0,0}"
                },
                {
                    "type":"loop",
                    "condition":"{i:2}",
                    "commands":
                    [
                        {"type":"fade", "time":"5", "end":"{f:0,1,0}"},
                        {"type":"fade", "time":"5", "end":"{f:1,0,0}"}
                    ]
                },
                {
                    "type":"loop",
                    "condition":"{i:10}",
                    "commands":
                    [
                        {"type":"fade", "time":"1", "end":"{f:0,0,1}"},
                        {"type":"fade", "time":"1", "end":"{f:0,0,0}"}
                    ]
                }
            ]
        }
    ]
}
</code></pre>

        </p>



        <!-- NOP -->
        <h3 id="command-nop">nop - Do nothing</h3>
        <h4>Description</h4>
        <p>
            The <strong>nop</strong> command does nothing during execution. It can be send as single command to stop the current running command.
            That works because if a <a href="#communication-client-message">client message</a> contains a valid commands section rgb-pi stops the current
            running command, initialized the new one and executes it til it's finished.
        </p>

        <h4>Syntax</h4>
        <p>
        The JSON-object of the <strong>nop</strong> command must set "nop" as "type".
        </p>
<pre><code>
{
    "commands":
    [
        {
            "type":"nop"
        }
    ]
}
</code></pre>

    </div>

    <div id="filters"></div>

    <div id="requests"></div>

<div id="datatypes">
        <h2>Data types</h2>
        <p>In order to control RGB-Pi in a flexible and dynamic way, we created some complex datatypes.
        These have unlike other communication structures their own format.
        </p>
        <p>Each data type is a string which is enclosed with <strong>{}</strong>-brackets. Currently there a <strong>3</strong>
        different data types that can be used in RGB-Pi messages: Color, Time and Condition
        </p>
        <p>Each data type is described in the following format: <strong>{SUBTYPE:VALUE}</strong>, where SUBTYPE describes how the VALUE is interpreted.
        More details to the data types and the way you declare the are found below.</p>
        <!-- COLOR -->
        <div id="datatype-color">
            <h3>Color</h3>
            <p>Color represents like the name hints a color in RGB format. A color can be defined in multiple ways. </p>
            <p id="datatype-color-syntax">Syntax: <strong>{b|f|x|r:string[:hex-byte]}</strong></p>
            <ul>
                <li>
                    <strong>b</strong> - Byte representation, where the color is described with 3 values between 0-255 for each channel<br/>
                    <strong>Syntax: {b:R,G,B}</strong>
                    <ol>
                        <li>example: <strong>{b:165,42,42}</strong> - this would create the color brown</li>
                    </ol>
                </li>
                <li>
                    <strong>f</strong> - Float representation, where the color is described with 3 values between 0.0-1.0 for each channel<br/>
                    <strong>Syntax: {f:R,G,B}</strong>
                    <ol>
                        <li>example: <strong>{f:0.647,0.165,0.165}</strong> - this would create the color brown</li>
                    </ol>
                </li>
                <li>
                    <strong>x</strong> - Hexstring representation, where of the color is described as 6-character-hex string (RRGGBB)<br/>
                    <strong>Syntax: {x:RRGGBB}</strong>
                    <ol>
                        <li>example: <strong>{x:A52A2A}</strong> - this would create the color brown</li>
                    </ol>
                </li>
                <li>
                    <strong>r</strong> - Random float representation, where the color is described with 3 ranges between 0.0-1.0 for each channel<br/>
                    <strong>Syntax: {r:R1-R2,G1-G2,B1-B2}</strong>
                    <ol>
                        <li>example: <strong>{r:0.5-1,0-1,0-0}</strong> - random color in half of the red spectrum and the whole green spectrum</li>
                    </ol>
                </li>
            </ul>

            <p>All this variations can be applied to one or more specific <strong>addresses</strong> of a led-stripe.</p>
            <p>
            As you see in the description of the <a href="#datatype-color-syntax">color syntax</a>, there is an optional additional <strong>:hex-byte</strong>.<br/>
            This is used to address multiple led stripes with a 8-bit bitmask represented as hexa-decimal digit (e.g. 0x1 to address the first stripe).<br/>
            Here a single address list for each stripe:
            <ol>
            <li>LED-stripe = 0x1</li>
            <li>LED-stripe = 0x2</li>
            <li>LED-stripe = 0x4</li>
            <li>LED-stripe = 0x8</li>
            </ol>
            You can also write <strong>0x3</strong> to address the first two stripes, or <strong>0xF</strong> to address all stripes (this is the default value if no address is specified in the color literal)<br/>
            As you can see, a maximum number of 4 stripes are supported yet.<br/>
            <strong>Syntax: {SUBTYPE:VALUE:ADDRESS}</strong>
            <ol>
                <li>example: <strong>{b:255,0,0:0x1}</strong> - red color on the first LED-stripe</li>
                <li>example: <strong>{r:0-1,0,0:0x5}</strong> - random bright red color on the first and the third LED-stripe</li>
            </ol>

            <p>Note: Addressing is an experimental feature right now, it's only tested with the <a href="#command-cc">CC-command</a> yet.</p>
            </p>
        </div>

        <!-- TIME -->
        <div id="datatype-time">
            <h3>Time</h3>
            <p>The almost self-explained type name hints that this data type stands for a finite amount of time. it can be represented in 2 different ways.</p>
            <p id="datatype-time-syntax">Syntax: <strong>{c|r:string} | float</strong></p>
            <ul>
                <li>
                    <strong>c</strong> - Constant float value<br/>
                    <strong>Syntax: {c:T} | T</strong>
                    <ol>
                        <li>example: <strong>{c:10.5}</strong> - this would create a time object which represents 10.5 seconds </li>
                        <li>example: <strong>10.5</strong> - another, simplier way to describe the same amount of time is to write the value directly (this will be implicitly casted to the format of the first example)</li>
                    </ol>
                </li>
                <li>
                    <strong>r</strong> - Random time in a range between MIN and MAX<br/>
                    <strong>Syntax: {r:MIN,MAX}</strong>
                    <ol>
                        <li>example: <strong>{r:15,18.3}</strong> - this would create a time between 15 and 18.3 seconds</li>
                    </ol>
                </li>
            </ul>
        </div>

        <!-- CONDITION -->
        <div id="datatype-condition">
            <h3>Condition</h3>
            <p>A condition is an often needed element RGB-Pi commands. It is used to descide whenever a control mechanic has to stop or can continue.</p>
            <p id="datatype-condition-syntax">Syntax: <strong>{b|t|i|c:string} | bool</strong></p>
            <ul>
                <li>
                    <strong>c</strong> - Constant boolean value<br/>
                    <strong>Syntax: {b:B} | T</strong>
                    <ol>
                        <li>example: <strong>{c:0}</strong> - this would create condition which is always FALSE</li>
                        <li>example: <strong>1</strong> - another, simplier way to describe a constant condition value is to write the value directly, were <strong>0</strong> stands for FALSE and <strong>1</strong> for TRUE. (This will be implicitly casted to the format of the first example)</li>
                    </ol>
                </li>
                <li>
                    <strong>t</strong> - Timed condition, which gets FALSE after T seconds since the first check<br/>
                    <strong>Syntax: {t:T}</strong>
                    <ol>
                        <li>example: <strong>{t:20}</strong> - this would create a condition which is TRUE for 20 seconds and then becomes FALSE</li>
                    </ol>
                </li>
                <li>
                    <strong>i</strong> - Condition bound to an amount of checks/iterations. It is TRUE at the beginning and becomes FALSE after X checks/iterations<br/>
                    <strong>Syntax: {i:X}</strong>
                    <ol>
                        <li>example: <strong>{i:5}</strong> - this would create a condition which is TRUE the next 5 times it is checked and then becomes FALSE</li>
                    </ol>
                </li>
                <li>
                    <strong>c</strong> - A color condition is TRUE if the current color is not the same as Color, otherwise it bacomes FALSE.<br/>
                    <strong>Syntax: {c:Color}</strong>
                    <ol>
                        <li>example: <strong>{c:{x:000000}}</strong> - this would create a condition, which is TRUE if the current color is NOT black, otherwise it is FALSE</li>
                    </ol>
                </li>
            </ul>
        </div>
    </div>

</body>
</html>